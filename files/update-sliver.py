import json
import os
import requests
import time
import tarfile
import urllib
import pexpect
import re
import argparse

parser = argparse.ArgumentParser(
    description="Sliver C2 Aromry Installer & Updater",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
parser.add_argument("-u", "--user", help="GitHub User")
parser.add_argument("-t", "--token", help="GitHub User Token")
args = parser.parse_args()

user = args.user
token = args.token

def runSliverUpdateCommands():
    # Launch the Sliver C2 client with pexpect
    try:
        print("Starting Sliver Client")
        client = pexpect.spawn('sliver')
        # Wait for the Sliver shell to be ready
        client.expect('>', timeout=30) # Adjust timeout as needed

        # Update the sliver application
        print("Running sliver update")
        client.sendline('update')
        client.expect(re.compile(r'done!'.encode('utf-8')), timeout=30) # Adjust timeout as needed for the prompt
        # Exit the Sliver client
        print("Finished now exiting")
        client.sendline('exit')
        client.expect(pexpect.EOF)
        print("Commands executed successfully.")

    except pexpect.exceptions.TIMEOUT as e: print("A timeout occurred while waiting for a response from the Sliver client.")
    except pexpect.exceptions.EOF: print("The Sliver client closed unexpectedly.")
    except Exception as e: print(f"An unexpected error occurred: {e}")

# Execute the Update function
runSliverUpdateCommands()

def extractAndDeleteTarFile(sourceTarFilePath, targetDirectory):
    """
    Extracts a tar file to a specified directory and then deletes the original tar file.

    Parameters:
    - sourceTarFilePath (str): The path to the tar file to be extracted.
    - targetDirectory (str): The directory where the tar file will be extracted.

    Returns:
    None
    """

    # Check if the source tar file exists
    if not os.path.exists(sourceTarFilePath):
        print(f"The file {sourceTarFilePath} does not exist.")
        return

    # Ensure the target directory exists, create if it doesn't
    if not os.path.exists(targetDirectory):
        os.makedirs(targetDirectory)
        print(f"Created the directory {targetDirectory}.")

    try:
        # Open the tar file
        with tarfile.open(sourceTarFilePath, "r") as tar:
            # Extract all contents of the tar file to the target directory
            tar.extractall(path=targetDirectory)
            print(f"Extracted {sourceTarFilePath} to {targetDirectory}.")
    except Exception as e:
        print(f"An error occurred: {e}")
        return

    try:
        # Delete the original tar file
        os.remove(sourceTarFilePath)
        print(f"Deleted the original tar file: {sourceTarFilePath}.")
    except Exception as e:
        print(f"Failed to delete the original tar file: {e}")


def downloadLatestRelease(repoOwner, repoUrl, repoName, assetName, outputPath):
    """
    Download the latest release of a binary from a GitHub repository.

    Parameters:
    - repoOwner: Owner of the repository (e.g., "octocat")
    - repoName: Name of the repository (e.g., "Hello-World")
    - assetName: Name of the binary asset to download (e.g., "app.zip")
    - outputPath: Local path to save the downloaded file

    This function does not require authentication for public repositories.
    For private repositories, you may need to add an access token in the headers.
    """

    # GitHub API URL for the latest release
    #repoUrl = f"https://api.github.com/repos/{repoOwner}/{repoName}/releases/latest"
    rUrl = repoUrl.rsplit('/', 1)[-1]
    apiUrl = f"https://api.github.com/repos/{repoOwner}/{rUrl}/releases/latest"
    print(apiUrl)

    # Send a GET request to the GitHub API
    response = requests.get(apiUrl, auth=(user,token))
    response.raise_for_status()  # Raise an exception for HTTP errors

    # Parse the JSON response
    releaseData = response.json()

    # Look for the asset with the specified name
    for asset in releaseData['assets']:
        if asset['name'].endswith('.tar.gz') == True:
            downloadUrl = asset['browser_download_url']
            break
    else:
        raise Exception(f"Asset {assetName} not found in the latest release.")

    # Download the asset
    response = requests.get(downloadUrl)
    response.raise_for_status()  # Raise an exception for HTTP errors

    outputFile = downloadUrl.rsplit('/', 1)[-1]
    output = outputPath + outputFile

    # Save the downloaded asset to the specified path
    with open(output, 'wb') as file:
        file.write(response.content)

    print(f"Downloaded {assetName} to {output}")

    # Untar the file and delete the TAR.GZ file.
    extractAndDeleteTarFile(output, outputPath + '/' + repoName)

def parse_json_extract_repo_urls(url):
    # Read JSON data from a file
    with urllib.request.urlopen("https://raw.githubusercontent.com/sliverarmory/armory/master/armory.json") as file:
        data = json.load(file)

    # Extract 'aliases' and 'extensions' names and repo URLs
    aliases_info = [(item['name'], item['repo_url']) for item in data['aliases']]
    extensions_info = [(item['name'], item['repo_url']) for item in data['extensions']]

    return aliases_info, extensions_info

# Specify the armory.json URL
url = 'https://raw.githubusercontent.com/sliverarmory/armory/master/armory.json'

# Create 'aliases' directory in '~/.sliver-client/' if it doesn't exist
aliases_dir_path = os.path.expanduser("~/.sliver-client/aliases")
if not os.path.exists(aliases_dir_path):
    os.makedirs(aliases_dir_path)
    print(f"\nDirectory created: {aliases_dir_path}")
else:
    print(f"\nDirectory already exists: {aliases_dir_path}")

# Create 'aliases' directory in '~/.sliver-client/' if it doesn't exist
extensions_dir_path = os.path.expanduser("~/.sliver-client/extensions")
if not os.path.exists(extensions_dir_path):
    os.makedirs(extensions_dir_path)
    print(f"\nDirectory created: {extensions_dir_path}")
else:
    print(f"\nDirectory already exists: {extensions_dir_path}")

# Extract names and URLs
aliases_info, extensions_info = parse_json_extract_repo_urls(url)

repoOwner = "sliverarmory"

# Print extracted information
print("\nBegin Installing Aliases")
for name, url in aliases_info:
    print(f"Installing Alias {name}: {url}")
    repoName = f"{name}".replace(' ', '-')
    assetName = f"{repoName}".lower() + ".tar.gz"
    outputPath = f"{aliases_dir_path}/"
    repoUrl = f"{url}"
    downloadLatestRelease(repoOwner, repoUrl, repoName, assetName, outputPath)
    time.sleep(1)

print("\nCompleted Installing Aliases")

print("\nBegin Installing Extensions")
for name, url in extensions_info:
    print(f"Installing Extention {name}: {url}")
    repoName = f"{name}"
    assetName = f"{repoName}".lower() + ".tar.gz"
    outputPath = f"{extensions_dir_path}/"
    repoUrl = f"{url}"
    downloadLatestRelease(repoOwner, repoUrl, repoName, assetName, outputPath)
    time.sleep(1)
print("\nCompleted Installing Extensions")